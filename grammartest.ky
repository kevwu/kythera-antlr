// line comment
/* Block level
multi line
comment */


// boolean literal
let myBool = false
myBool

// integer literal
let myInt = 99
myInt

// float literal
let myFloat = 3.14159
myFloat

// string literal
let myStr = "hello"
myStr

// object literal
let myObj = {
    int a
    b = 2.0
    c = "asdf"
}
myObj

// function literal
let myFn = fn(int x): str {
    let a = 0
}
myFn

// null
let n = null
n

// declaration by new
let m = new int
m
m = 2
m + 2

// TODO arithmetic operations cause parser ambiguities, fix this
// 2 + 2
// a + b

// arrays are temporarily removed from the language, will be added later
// let myArr = new int[10]
// let myArr = new int[]
// a = myArr[10]
// myArr[10] = 2

// function call
// aFunction()
// aFunction(2)
// aFunction(2, "beep beep meme creep")

// anonymous function call
fn(int a): int {
    let q = 99
    let r = q
    return q
}(10)

// boolean expression
let a = 0
let b = 1
a = 3
a == b
a == a
a == 3
// arithmetic expression
// demonstrates strict typing
a + b

a
a % 2

// boolean negation
myBool
!myBool

!false

let fibo = fn(int x): int {
    if x == 1 {
        return 1
    }

    if x == 0 {
        return 0
    }

    return fibo(x-1) + fibo(x-2)
}

fibo(10)

// if statement
if false {
    a a a a a a
}

if false {
    a
} else {
    b
}

// if-if-else
if false {
    a
} else if false {
    23
} else {
    "yay"
}

// if-else
if a == b {
    a
} else {
    b
}

// while
while a == b {
    a = a + 2
}

let x = 0
while x < 10 {
    x = x + 1
}

x

// name statements
name myType int
name myFnType fn(int) : str
name myObjType obj{
    int ab
    str b
}

let myCustomFnInstance = new myFnType

myCustomFnInstance = fn(float a): str {
    return "helo"
}

myCustomFnInstance("asdf")

let myCustomObjInstance = new myObjType

myCustomObjInstance = {
    b = "asdf"
    ab = 2
    c = "zzz"
}

// package statements
// import "myThing"
// include "./myFile"

// export a